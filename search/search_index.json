{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>fcache is a FlatBuffers cache over WebSockets.</p> <p>There is support for key-values and lists, with more coming soon.</p> <p>FlatBuffers offer zero-copy deserialising: when the server receives data, it can deserialise without an intermediate step which requires allocating memory (as with ProtoBuf), and is considerably more compact than JSON.</p>"},{"location":"kv/","title":"Key Values","text":"<ul> <li>Key must be a string</li> <li>Supported values:    <ul> <li>integer</li> <li>unsigned integer</li> <li>float</li> <li>bool</li> <li>string</li> <li>List/vector/array of the above</li> </ul> </li> </ul>"},{"location":"kv/#listarrayvector-values","title":"List/Array/Vector Values","text":"<p>A value which is not scalar is serialised as a <code>TypedVector</code>. This means that all elements of the vector must be the same type. </p> <p>Using Python as an example:</p> Lists<pre><code>data =\n{\n  'animals':['cat', 'dog', 'horse'],\n  'scores':[50,55,5],\n  'anything':['xyz', 15, False]\n}\n</code></pre> <p>Storing <code>animals</code> and <code>scores</code> will succeed but <code>anything</code> will fail.</p>"},{"location":"kv/#caching-json","title":"Caching JSON","text":"<p>There is no native JSON support, so JSON must be stored as either as a string or converting to a compatible dictionary/map structure.</p> <p>Note</p> <p>The Python API functions <code>set</code>, <code>add</code> and <code>clear_set</code> accept <code>dict</code> for key values.</p>"},{"location":"lists/","title":"Lists","text":"<p>A list is a node based doubly linked list with support for:</p> <ul> <li>integers (signed and unsigned)</li> <li>floats</li> <li>strings</li> </ul> <p>Lists can be sorted or unsorted: </p> <ul> <li>An unsorted list retains the order as added</li> <li>A sorted list ensures nodes are always in ascending order. If the items being added are already sorted, this can be signalled when adding, reducing workload </li> </ul> <p>For both sorted and unsorted lists get items:</p> <ul> <li>Based on a range <code>[start,stop)</code> with negative positions permitted (similar to Python slicing)</li> <li>Some commands have reverse versions, which work similar to C++'s reverse iterators</li> </ul>"},{"location":"lists/#add-items","title":"Add Items","text":"<ul> <li>Unsorted List: items can be added anywhere in the list</li> <li>Sorted List: order is defined by the sorted order</li> </ul>"},{"location":"lists/#get-items","title":"Get Items","text":"<p>The server API allows iterating a list from head to tail or tail to head.</p> <p>In the Python API there is <code>get_n()</code> which returns <code>n</code> items from a given starting position.</p> <pre><code>await lists.get_n('scores', start=0, count=3)\n</code></pre> <p>This returns the first three items.</p> <p>The reverse version iterates from the tail to head, so returns the last three items:</p> <pre><code>await lists.get_n_reverse('scores', start=0, count=3)\n</code></pre>"},{"location":"lists/#remove-items","title":"Remove Items","text":"<p>Items can be removed using their position or based on a value.</p> <p>For example, in the Python API we can remove nodes with a value of <code>100</code> in range <code>[0,8)</code>:</p> <pre><code>await lists.remove_if_eq('scores', start=0, stop=8, val=100)\n</code></pre>"},{"location":"lists/#intersect","title":"Intersect","text":"<p>Sorted lists of the same type can be intersected, with support for start/stop positions within each list.</p> <pre><code>await lst.create('i1', type='int')\nawait lst.create('i2', type='int')\n\nawait lst.add('i1', [0,1,2,5,5,5,6,7,8,9,10], items_sorted=True)\nawait lst.add('i2', [0,1,2,5,5,5,6,7], items_sorted=True)\n\nprint(await lst.intersect('i1', 'i2'))\nprint(await lst.intersect('i1', 'i2', l1_stop=6))\n\n# you can also set new_name_list, which creates a new list for\n# for the intersected items, rather than returning them\n</code></pre> Output<pre><code>[0, 1, 2, 5, 5, 5, 6, 7]\n[0, 1, 2, 5, 5, 5]\n</code></pre>"},{"location":"start/","title":"Run","text":"<p>If building from source, the binary is in <code>server/release</code>.</p>"},{"location":"start/#command-line-arguments","title":"Command Line Arguments","text":"Name Description Default ip The IP address the server will listen on 127.0.0.1 port The port 1987 maxPayload Max size, in bytes, of the WebSocket payload. Messages exceeding this are ignored 2048 <p>Custom IP: <pre><code>./fcache --ip=192.168.1.120\n</code></pre></p> <p>Custom port and max payload: <pre><code>./fcache --port=2000 --maxPayload=8192\n</code></pre></p>"},{"location":"api_py/intro/","title":"Overview","text":"<p>The <code>fc.Client</code> manages the connection, with a separate class for KV specific commands (and in the future, arrays, lists, etc).</p> <p>The command classes require a <code>Client</code> object.</p>"},{"location":"api_py/intro/#connect","title":"Connect","text":"<pre><code>import fc\n\nasync def connect() -&gt; fc.Client:\n  try:\n    client = await fc.fcache(uri='ws://127.0.0.1:1987')\n    # or: client = await fc.fcache(ip='127.0.0.1', port=1987)\n  except:\n    print ('Failed to connect')\n    client = None\n  return client\n</code></pre>"},{"location":"api_py/intro/#exceptions","title":"Exceptions","text":"<ul> <li><code>ResponseError</code> : raised when a failed response is received</li> <li><code>ValueError</code> : raised by the API before a request is sent</li> <li><code>OSError</code> : if opening the connection fails</li> </ul>"},{"location":"api_py/intro/#kv","title":"KV","text":"<p>List Values</p> <ul> <li>A list cannot be empty</li> <li>If a key's value is a <code>list</code>, all elements must be the same type:</li> </ul> <pre><code>await kv.set({'a':[]})          # ValueError: empty, can't determine element type\nawait kv.set({'a':[1, 2, 3]})   # Ok\nawait kv.set({'b':[1, 2.5, 3]}) # ValueError: int, float, int    \n</code></pre> <pre><code>from fc.kv import KV\n\nasync def kv():\n  if (client := await connect()) is None:\n    return\n\n  # create API object for KV commands\n  kv = KV(client)\n\n  await kv.set({'player':'Monster',\n                'level':25,\n                'active':True,\n                'perks':['Armour','Kilt']})\n\n  # get single key, returns the value (or None if key not found)\n  age = await kv.get(key='level')\n  print(f'Age: {age}')\n\n  # get multiple keys, returns dict\n  rsp = await kv.get(keys=['player', 'active'])\n  print(f\"Player: {rsp['player']}, Active: {rsp['active']}\")\n\n  # get list\n  print(await kv.get(key='perks'))\n</code></pre> Output<pre><code>Age: 25\nPlayer: Monster, Active: True\n['Armour', 'Kilt']\n</code></pre>"},{"location":"api_py/intro/#types","title":"Types","text":"Python FlatBuffers/FlexBuffers Server int int <code>int64</code> float float <code>float</code> (4 bytes) str string <code>std::vector&lt;char&gt;</code> bool bool <code>bool</code> bytes BLOB <code>std::vector&lt;uint8_t&gt;</code> list[int] TypedVector: VECTOR_INT <code>std::vector&lt;int64&gt;</code> list[float] TypedVector: VECTOR_FLOAT <code>std::vector&lt;float&gt;</code> list[str] TypedVector: VECTOR_KEY <code>std::vector&lt;uint8_t&gt;</code> list[bool] TypedVector: VECTOR_BOOL <code>std::vector&lt;bool&gt;</code> <p>Note</p> <p>A <code>TypedVector</code> is a type of FlexBuffer vector, where each element is the same type.</p>"},{"location":"api_py/intro/#lists","title":"Lists","text":"<p>Lists are node based doubly linked lists. There are two types, <code>SortedList</code> and <code>UnsortedList</code>.</p>"},{"location":"api_py/intro/#unsorted","title":"Unsorted","text":"Unsorted<pre><code>from fc.list import UnsortedList\n\nasync def unsorted_lists():\n  if (client := await connect()) is None:\n    return\n\n  # create API object for list functions\n  list = List(client)\n\n  # delete any existing lists\n  await list.delete_all()\n\n  # create list for integers\n  await list.create('scores', type='int')\n  # add these items to head\n  await list.add_head('scores', [25,35,45,55])\n  # insert in between 35 and 45 (at position 2)\n  await list.add('scores', [40], pos=2)\n  # add two more to the tail\n  await list.add_tail('scores', [60, 65])\n\n  # get everything from the first item\n  print(f\"a. {await list.get_n('scores')}\")\n  # get everything in reverse\n  print(f\"b. {await list.get_n_reverse('scores')}\")\n  # # get the first 3 \n  print(f\"c. {await list.get_n('scores', count=3)}\")\n  # # get the last 2\n  print(f\"d. {await list.get_n('scores', start=5)}\")\n  # get middle 3 with range (could also use get_n())\n  print(f\"e. {await list.get_range('scores', start=2, stop=5)}\")\n  # get middle 5 in reverse, using negative index\n  print(f\"f. {await list.get_range_reverse('scores', start=1, stop=-1)}\")\n</code></pre> Output<pre><code>a. [25, 35, 40, 45, 55, 60, 65]\nb. [65, 60, 55, 45, 40, 35, 25]\nc. [25, 35, 40]\nd. [60, 65]\ne. [40, 45, 55]\nf. [60, 55, 45, 40, 35]\n</code></pre>"},{"location":"api_py/intro/#sorted","title":"Sorted","text":"Sorted<pre><code>from fc.list import SortedList\n\nasync def sorted_lists():\n  if (client := await connect()) is None:\n    return\n\nlst = SortedList(client)\n\nawait lst.delete_all()\n\nawait lst.create('scores', type='int')\n\nawait lst.add('scores', [45,35,25,55])\nprint(await lst.get_n('scores'))\n\nawait lst.add('scores', [50,20,100,40,90])\nprint(await lst.get_n('scores'))\n\nawait lst.add('scores', [41,42], items_sorted=True)\nprint(await lst.get_n('scores'))\n\nawait lst.add('scores', [1,2,3], items_sorted=True)\nprint(await lst.get_n('scores'))\n\nawait lst.add('scores', [100,101,102], items_sorted=True)\nprint(await lst.get_n('scores'))\n\nprint(await lst.get_n('scores', start=5, count=4))\nprint(await lst.get_n_reverse('scores', start=8, count=4))\n</code></pre> Output<pre><code>[25, 35, 45, 55]\n[20, 25, 35, 40, 45, 50, 55, 90, 100]\n[20, 25, 35, 40, 41, 42, 45, 50, 55, 90, 100]\n[1, 2, 3, 20, 25, 35, 40, 41, 42, 45, 50, 55, 90, 100]\n[1, 2, 3, 20, 25, 35, 40, 41, 42, 45, 50, 55, 90, 100, 100, 101, 102]\n[35, 40, 41, 42]\n[42, 41, 40, 35]\n</code></pre>"},{"location":"api_py/kv/add/","title":"add","text":"<pre><code>async def add(kv: dict) -&gt; None\n</code></pre> <p>Sets new key(s) but unlike set, if a key already exists, the value is not replaced.</p> <p>Note</p> <p>If value is a <code>list</code>, all items must be the same type.</p>"},{"location":"api_py/kv/add/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True})\n# calling add() will not update age\nawait kv.add({'age':25})\n</code></pre>"},{"location":"api_py/kv/clear/","title":"clear","text":"<pre><code>async def clear() -&gt; None\n</code></pre> <p>Deletes all keys.</p> <p>You can also use <code>clear_set()</code> to delete all keys then set new keys in a single call.</p>"},{"location":"api_py/kv/clear/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True, 'city':'London'})\nawait kv.clear()\n</code></pre>"},{"location":"api_py/kv/clear_set/","title":"clear_set","text":"<pre><code>async def clear_set(kv:dict) -&gt; None:\n</code></pre> <p>Deletes all keys then sets new keys in a single command.</p> <p>Note</p> <p>If value is a <code>list</code>, all items must be the same type.</p>"},{"location":"api_py/kv/clear_set/#examples","title":"Examples","text":"<pre><code>await kv.set({'k1':10, 'k2':20})\nawait kv.clear_set({'k3':30, 'k4':40})\n# only k3 and k4 exist\n</code></pre>"},{"location":"api_py/kv/contains/","title":"contains","text":"<pre><code>async def contains(keys: list) -&gt; set\n</code></pre> <p>Given a list of keys, return those which exist.</p>"},{"location":"api_py/kv/contains/#returns","title":"Returns","text":"<p>A <code>set</code> of keys that exist.</p>"},{"location":"api_py/kv/contains/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True, 'city':'London'})\nexist = await kv.count()\n# exist contains 'age' and 'user'\n</code></pre>"},{"location":"api_py/kv/count/","title":"count","text":"<pre><code>async def count() -&gt; int\n</code></pre> <p>Gets the number of keys.</p>"},{"location":"api_py/kv/count/#returns","title":"Returns","text":"<p>The number of keys that exist.</p>"},{"location":"api_py/kv/count/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True, 'city':'London'})\ncount = await kv.count() # 4\n</code></pre>"},{"location":"api_py/kv/get/","title":"get","text":"<pre><code>async def get(key=None, keys=[]) -&gt; dict | Any\n</code></pre> <p>Gets a single key or multiple keys.</p>"},{"location":"api_py/kv/get/#returns","title":"Returns","text":"<p>Called with:</p> <ul> <li><code>key</code>: if key exists the value is returned, otherwise <code>None</code></li> <li><code>keys</code>: all key values in a <code>dict</code></li> </ul>"},{"location":"api_py/kv/get/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True})\n\n# get single key, returns the value\nage = await kv.get(key='age')\nprint(f'Age: {age}')\n\n# get multiple keys, returns dict\nrsp = await kv.get(keys=['user', 'active'])\nprint(f\"User: {rsp['user']}, Active: {rsp['active']}\")\n</code></pre> <pre><code>Age: 25\nUser: user1, Active: True\n</code></pre>"},{"location":"api_py/kv/remove/","title":"remove","text":"<pre><code>async def remove(key='', keys=[]) -&gt; None\n</code></pre> <p>Deletes one or multiple keys.</p> <ul> <li><code>key</code> : individual key to delete</li> <li><code>keys</code> : list of keys to delete</li> </ul> <p>If a key does not exist it is not considered an error.</p>"},{"location":"api_py/kv/remove/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True, 'city':'London'})\nawait kv.remove(key='age')\nawait kv.remove(keys=['user','city'])\n# only 'active' remains\n</code></pre>"},{"location":"api_py/kv/set/","title":"set","text":"<pre><code>async def set(kv: dict) -&gt; None\n</code></pre> <p>Sets new key(s). If a key already exists, the value is replaced.</p> <p>Note</p> <p>If value is a <code>list</code>, all items must be the same type.</p>"},{"location":"api_py/kv/set/#examples","title":"Examples","text":"Basics<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True})\n</code></pre> Blob<pre><code>file_data = bytes()\nwith open('cat.jpg', mode='rb') as file:\n  file_data = file.read()\n\nkv = KV(client)\n\nawait kv.set({'img_cat':file_data})\n\nif data := await kv.get(key='img_cat'):\n  with open('cat_rsp.jpg', mode='wb') as file:\n    file.write(data)\n    print('Image written')\n</code></pre>"},{"location":"api_py/list/add/","title":"add","text":"<p>Unsorted List <pre><code>async def add(name: str, items: typing.List[int|str|float], *, pos: int) -&gt; None\n</code></pre></p> <p>Sorted List <pre><code>async def add(name: str, items: typing.List[int|str|float], items_sorted:bool = False) -&gt; None\n</code></pre></p> <p>These functions add items to the list. The only difference being that a sorted list determines the order so the <code>pos</code> is not relevant.</p> Param Info name Name of the list items The items to add to the list. Each item must be of the appropriate type for the list."},{"location":"api_py/list/add/#unsorted","title":"Unsorted","text":"Param Info pos The position to begin inserting. Positions begin at <code>0</code>. <p>Inserts items into the list, starting at position <code>pos</code>, in the same order as <code>items</code>.</p> <ul> <li><code>pos</code> must be <code>&gt;= 0</code></li> <li>If <code>pos</code> is higher than the list size, the items are appended</li> </ul>"},{"location":"api_py/list/add/#sorted","title":"Sorted","text":"Param Info items_sorted <code>True</code>: set only if <code>items</code> are already sorted in ascending order<code>False</code>: the server will sort during insertion <p>The sort order is determined by the <code>&lt;</code> operator and is always ascending order.</p>"},{"location":"api_py/list/add/#examples","title":"Examples","text":"Unsorted<pre><code>from fc.list import UnsortedList\n\nlst = UnsortedList()\n\nawait lst.create('names', type='str')\n\nawait lst.add('names', ['Arya', 'Fiona'], pos=0) # alternative to add_head()\nprint(await lst.get_n('names'))\n\nawait lst.add('names', ['David', 'Bob', 'Charlie'], pos=1)\nprint(await lst.get_n('names'))\n\nawait lst.add('names', ['Emma'], pos=3)\nprint(await lst.get_n('names'))\n</code></pre> Output<pre><code>['Arya', 'Fiona']\n['Arya', 'David', 'Bob', 'Charlie', 'Fiona']\n['Arya', 'David', 'Bob', 'Emma', 'Charlie', 'Fiona']\n</code></pre> Sorted<pre><code>from fc.list import SortedList\n\nlst = SortedList()\n\nawait lst.create('names', type='str')\n\nawait lst.add('names', ['Arya', 'Fiona'], items_sorted=True)\nprint(await lst.get_n('names'))\n\nawait lst.add('names', ['David', 'Bob', 'Charlie'])\nprint(await lst.get_n('names'))\n\nawait lst.add('names', ['Emma'])\nprint(await lst.get_n('names'))\n</code></pre> Output<pre><code>['Arya', 'Fiona']\n['Arya', 'Bob', 'Charlie', 'David', 'Fiona']\n['Arya', 'Bob', 'Charlie', 'David', 'Emma', 'Fiona']\n</code></pre>"},{"location":"api_py/list/add_head/","title":"add_head","text":"<pre><code>async def add_head(name: str, items: typing.List[int|str|float]) -&gt; None\n</code></pre> <p>Note</p> <p>Unsorted list only</p> <p>Adds to items to the list's head. Items are added in the same order as <code>items</code>.</p> Param Info name Name of the list items The items to add to the list. Each item must be of the appropriate type for the list."},{"location":"api_py/list/add_head/#examples","title":"Examples","text":"<pre><code>await list.create('names', type='str')\nawait list.add_head('names', ['Arya', 'Charlie'])\n# [Arya, Charlie]\nawait list.add_head('names', ['Adam', 'Alice'])\n# [Adam, Alice, Arya, Charlie]\n</code></pre>"},{"location":"api_py/list/add_tail/","title":"add_tail","text":"<pre><code>async def add_tail(name: str, items: typing.List[int|str|float]) -&gt; None\n</code></pre> <p>Note</p> <p>Unsorted list only</p> <p>Appends items to the list. Items are added in the same order as <code>items</code>.</p> Param Info name Name of the list items The items to add to the list. Each item must be of the appropriate type for the list."},{"location":"api_py/list/add_tail/#examples","title":"Examples","text":"<pre><code>await list.create('names', type='str')\n# you can add_tail() on an empty list\nawait list.add_tail('names', ['Arya', 'Charlie'])\n# [Arya, Charlie] , Arya is the head, Charlie the tail\nawait list.add_tail('names', ['David', 'Fiona'])\n# [Arya, Charlie, David, Fiona]\n</code></pre>"},{"location":"api_py/list/create/","title":"create","text":"<pre><code>async def create(name: str, *, type: str, fail_on_duplicate:bool = True) -&gt; None\n</code></pre> <p>Creates a new list with the given name and type.</p> Param Info name Name of the list, used in subsequent list functions type Must be one of: <code>int</code>, <code>float</code> or <code>str</code> fail_on_duplicate <code>True</code>: <code>ResponseError</code> is raised if a list with this <code>name</code> already exists<code>False</code>: if the name already exists, no changes are made to the existing list and an <code>ResponseError</code> is not raised"},{"location":"api_py/list/create/#examples","title":"Examples","text":"<pre><code># create an int list called 'scores' and add four items\nawait list.create('scores', type='int')\nawait list.add_head('scores', [1,2,3,4])\n\n# string list\nawait list.create('names', type='str')\nawait list.add_head('names', ['Alice', 'Charlie'])\nawait list.add('names', ['Bob'], pos=1)\nawait list.add_tail('names', ['David'])\n# [Alice, Bob, Charlie, David]\n</code></pre>"},{"location":"api_py/list/delete/","title":"delete","text":"<p><pre><code>async def delete(names: typing.List[str]) -&gt; None\n</code></pre> Delete list(s).</p> <p>To delete all lists without specifying each name, use delete_all().</p>"},{"location":"api_py/list/delete/#examples","title":"Examples","text":"<pre><code>await list.create('scores', type='int')\nawait list.create('usernames', type='str')\nawait list.delete(['scores', 'usernames'])\n</code></pre>"},{"location":"api_py/list/delete_all/","title":"delete_all","text":"<p><pre><code>async def delete_all() -&gt; None\n</code></pre> Delete all lists.</p> <p>To delete all single or multiple lists by name, use delete().</p>"},{"location":"api_py/list/delete_all/#examples","title":"Examples","text":"<pre><code>await list.create('scores', type='int')\nawait list.create('usernames', type='str')\nawait list.delete_all()\n</code></pre>"},{"location":"api_py/list/get_head/","title":"get_head","text":"<pre><code>async def get_head(name: str):\n</code></pre> <p>Returns the item at the head.</p>"},{"location":"api_py/list/get_head/#returns","title":"Returns","text":"<p>If the list is empty returns <code>None</code>, otherwise the item.</p>"},{"location":"api_py/list/get_head/#examples","title":"Examples","text":"<pre><code>await list.create('names', type='str')\nawait list.add_head('names', ['Arya', 'Fiona'])\nprint(await list.get_head('names')) # 'Arya'\n</code></pre>"},{"location":"api_py/list/get_n/","title":"get_n","text":"<pre><code>async def get_n(name: str, *, start: int = 0, count: int = None) -&gt; list:\n</code></pre> <p>Returns <code>count</code> number of items, beginning from <code>start</code> position.</p> <ul> <li> <p><code>count</code></p> <ul> <li><code>None</code> will get until to and including the tail</li> <li>Cannot be negative</li> </ul> </li> <li> <p><code>start</code> cannot be negative</p> </li> </ul> <p>Note</p> <p><code>start</code> is zero based. The head is <code>0</code>.</p>"},{"location":"api_py/list/get_n/#examples","title":"Examples","text":"<pre><code>await list.create('list', type='str')\nawait list.add_head('list', ['A', 'B', 'C', 'D', 'E'])\n\nprint(await list.get_n('list'))           # all from head\nprint(await list.get_n('list', start=3))  # all from 4th item\nprint(await list.get_n('list', start=1, count=2)) # 2 from 2nd item\nprint(await list.get_n('list', count=3))          # 3 from head\n</code></pre> Output<pre><code>['A', 'B', 'C', 'D', 'E']\n['D', 'E']\n['B', 'C']\n['A', 'B', 'C']\n</code></pre>"},{"location":"api_py/list/get_n_reverse/","title":"get_n_reverse","text":"<pre><code>async def get_n_reverse(name: str, *, start: int = 0, count: int = None) -&gt; list:\n</code></pre> <p>Returns <code>count</code> number of items, beginning from <code>start</code> position.</p> <p>This is the same as get_n() but <code>start</code> is from the tail, i.e. <code>start=0</code> is the tail, rather than the head.</p> <ul> <li> <p><code>count</code></p> <ul> <li><code>None</code> will get to and including the head</li> <li>Cannot be negative</li> </ul> </li> <li> <p><code>start</code> cannot be negative</p> </li> </ul> <p>Note</p> <p><code>start</code> is zero based. The tail is <code>0</code>.</p>"},{"location":"api_py/list/get_n_reverse/#examples","title":"Examples","text":"<pre><code>await list.create('list', type='str')\nawait list.add_head('list', ['A', 'B', 'C', 'D', 'E'])\n\nprint(await list.get_n_reverse('list'))           # all from tail\nprint(await list.get_n_reverse('list', start=3))  # all from 4th item\nprint(await list.get_n_reverse('list', start=1, count=2)) # 2 from 2nd item\nprint(await list.get_n_reverse('list', count=3))          # 3 from tail\n</code></pre> Output<pre><code>['E', 'D', 'C', 'B', 'A']\n['B', 'A']\n['D', 'C']\n['E', 'D', 'C']\n</code></pre>"},{"location":"api_py/list/get_range/","title":"get_range","text":"<pre><code>async def get_range(name: str, *, start:int, stop: int = None) -&gt; list:\n</code></pre> <p>Get items using the range: <code>[start, stop)</code>.</p> <p>If <code>stop</code> is <code>None</code>, returns all remaining.</p> <p><code>start</code> and <code>stop</code> can be negative, similar to Python slicing:</p> <ul> <li><code>-1</code> is the tail</li> <li><code>-2</code> is the node before the tail</li> </ul> <p>Either or both <code>start</code> and <code>stop</code> can be negative/positive, but they must represent indices such that <code>start &lt; stop</code>.</p>"},{"location":"api_py/list/get_range/#returns","title":"Returns","text":"<p>A list of node values, or an empty list if the range is invalid of if <code>start == stop</code>.</p>"},{"location":"api_py/list/get_range/#examples","title":"Examples","text":"<pre><code>await list.create('list', type='str')\nawait list.add_head('list', ['A', 'B', 'C', 'D', 'E'])\n\nprint(await list.get_range('list', start=0))    # all from head\nprint(await list.get_range('list', start=2))    # all from 3rd item\nprint(await list.get_range('list', start=-2))   # all from 'D'\nprint(await list.get_range('list', start=1, stop=-2))   # 2nd item to 'D' exclusive\nprint(await list.get_range('list', start=-4, stop=-1))  # 'B' to tail exclusive\n\n# invalid: [3,1)\nprint(await list.get_range('list', start=-2, stop=1))\n# invalid: [3,2)\nprint(await list.get_range('list', start=3, stop=-3))\n</code></pre> Output<pre><code>['A', 'B', 'C', 'D', 'E']\n['C', 'D', 'E']\n['D', 'E']\n['B', 'C']\n['B', 'C', 'D']\n[]\n[]\n</code></pre>"},{"location":"api_py/list/get_range/#notes","title":"Notes","text":"<p>The API performs simple checks on the ranges to spot problems before sending the query, but it's not always possible without knowing the list's size.</p> <p>Consider the example above, this range is invalid:</p> <pre><code>print(await list.get_range('list', start=3, stop=-3))\n</code></pre> <p>But add two items and try again:</p> <pre><code>await list.add_tail('list', ['F','G'])\n# now [3,4)\nprint(await list.get_range('list', start=3, stop=-3)) \n</code></pre> Output<pre><code>['D']\n</code></pre>"},{"location":"api_py/list/get_range_reverse/","title":"get_range_reverse","text":"<p><pre><code>async def get_range_reverse(name: str, *, start:int, stop: int = None) -&gt; list:\n</code></pre> Get items using the range <code>[start, stop)</code>, but in reverse (tail to head).</p> <p>This is the same as get_range() but it iterates the list from tail to head:</p> <ul> <li>positive indices are relative to the tail<ul> <li><code>start=0</code> is the tail    </li> </ul> </li> <li>negative indices are relative to the head<ul> <li><code>stop=-1</code> is the head</li> </ul> </li> </ul> <p>If <code>stop</code> is <code>None</code>, returns all remaining.</p> <p><code>start</code> and <code>stop</code> can be negative, similar to Python slicing:</p> <ul> <li><code>-1</code> is the head</li> <li><code>-2</code> is the second node (the node after the head)</li> </ul> <p>Either or both <code>start</code> and <code>stop</code> can be negative/positive, but they must represent indices such that <code>start &lt; stop</code>.</p>"},{"location":"api_py/list/get_range_reverse/#returns","title":"Returns","text":"<p>A list of node values, or an empty list if the range is invalid of if <code>start == stop</code>.</p>"},{"location":"api_py/list/get_range_reverse/#examples","title":"Examples","text":"<pre><code>await list.create('list', type='str')\nawait list.add_head('list', ['A', 'B', 'C', 'D', 'E'])\n\nprint(await list.get_range_reverse('list', start=0))    # 0 is the tail\nprint(await list.get_range_reverse('list', start=2))\nprint(await list.get_range_reverse('list', start=-2))\nprint(await list.get_range_reverse('list', start=1, stop=-2))\nprint(await list.get_range_reverse('list', start=-4, stop=-1))\n</code></pre> Output<pre><code>['E', 'D', 'C', 'B', 'A']\n['C', 'B', 'A']\n['B', 'A']\n['D', 'C']\n['D', 'C', 'B']\n</code></pre>"},{"location":"api_py/list/get_tail/","title":"get_tail","text":"<pre><code>async def get_tail(name: str):\n</code></pre> <p>Returns the item at the tail.</p>"},{"location":"api_py/list/get_tail/#returns","title":"Returns","text":"<p>If the list is empty returns <code>None</code>, otherwise the item.</p>"},{"location":"api_py/list/get_tail/#examples","title":"Examples","text":"<pre><code>await list.create('names', type='str')\nawait list.add_head('names', ['Arya', 'Fiona'])\nprint(await list.get_tail('names')) # 'Fiona'\n</code></pre>"},{"location":"api_py/list/intersect/","title":"intersect","text":"<pre><code>async def intersect(list1: str, list2: str, *,\n                    l1_start:int=0, l1_stop:int=None,\n                    l2_start:int=0, l2_stop:int=None,\n                    new_list_name:str=None) -&gt; None | typing.List[int|float|str]\n</code></pre> <p>Intersects <code>list1</code> and <code>list2</code>. They must the same type.</p> <p>Positions within each list can be defined, with defaults applying the intersection over both entire lists.</p> Param Info list1, list2 The lists to intersect l1_start, l1_stop Restricts the nodes for intersecting within <code>list1</code>. Note, <code>l1_stop</code> is exclusive. Set <code>l1_stop=None</code> to including all remaining nodes l2_start, l2_stop Restricts the nodes for intersecting within <code>list2</code>. Note, <code>l2_stop</code> is exclusive.Set <code>l2_stop=None</code> to including all remaining nodes new_list_name - If <code>None</code>: intersected nodes are returned- Otherwise creates a new list for the intersected nodes, and does not return the nodes  <ul> <li><code>l1_start</code> and <code>l1_stop</code> restrict the intersection in <code>list1</code> to <code>[l1_start, l1_stop)</code></li> <li><code>l2_start</code> and <code>l2_stop</code> restrict the intersection in <code>list2</code> to <code>[l2_start, l2_stop)</code></li> </ul> <p>Stop position of <code>None</code> includes all remaining nodes in the list.</p>"},{"location":"api_py/list/intersect/#returns","title":"Returns","text":"<p>It depends on <code>new_list_name</code>:</p> <ul> <li>If <code>None</code>:<ul> <li>Returns the intersected nodes</li> </ul> </li> <li>If a valid string:<ul> <li>Returns <code>None</code></li> <li>The intersected nodes are added to the new list</li> </ul> </li> </ul>"},{"location":"api_py/list/intersect/#examples","title":"Examples","text":"<p>The code comments below exclude the value at the stop position as it's exclusive.</p> Int Lists<pre><code>await lst.create('i1', type='int')\nawait lst.create('i2', type='int')\n\nawait lst.add('i1', [0,1,2,5,5,5,6,7,8,9,10], items_sorted=True)\nawait lst.add('i2', [0,1,2,5,5,5,6,7], items_sorted=True)\n\n# entire lists\nprint(await lst.intersect('i1', 'i2'))\n\n# [0,1,2,5,5,5] n [0,1,2,5,5,5,6,7]\nprint(await lst.intersect('i1', 'i2', l1_stop=6))\n\n# [0,1,2,5,5,5,6,7,8,9,10] n [0,1,2]\nprint(await lst.intersect('i1', 'i2', l2_stop=3))\n\n# [5,5,5] n [0,1,2,5,5,5]\nprint(await lst.intersect('i1', 'i2', l1_start=3, l1_stop=6, l2_stop=-2))\n</code></pre> Output<pre><code>[0, 1, 2, 5, 5, 5, 6, 7]\n[0, 1, 2, 5, 5, 5]\n[0, 1, 2]\n[5, 5, 5]\n</code></pre> <p></p> String Lists<pre><code>await lst.create('s1', type='str')\nawait lst.create('s2', type='str')\n\nawait lst.add('s1', ['apple', 'cider', 'painful', 'tequila', 'yes'], items_sorted=True)\nawait lst.add('s2', ['apple', 'beer', 'cider', 'no', 'painful', 'tequila'], items_sorted=True)\n\n# entire lists\nprint(await lst.intersect('s1', 's2'))\n\n# ['apple', 'cider'] n ['apple', 'beer', 'cider']\nprint(await lst.intersect('s1', 's2', l1_stop=2, l2_stop=-3))\n\n# ['painful', 'tequila', 'yes'] n ['painful', 'tequila']\nprint(await lst.intersect('s1', 's2', l1_start=2, l2_start=4))\n</code></pre> Output<pre><code>['apple', 'cider', 'painful', 'tequila']\n['apple', 'cider']\n['painful', 'tequila']\n</code></pre> <p></p> Create new list from intersected nodes<pre><code>await lst.create('list1', type='int')\nawait lst.create('list2', type='int')\n\nawait lst.add('list1', [1,2,3,4,5,6,7,8,9,10], items_sorted=True)\nawait lst.add('list2', [1,2,9,10], items_sorted=True)\n\nawait lst.intersect('list1', 'list2', new_list_name='list3')\nprint(await lst.get_n('list3'))\n</code></pre> Output<pre><code>[1, 2, 9, 10]\n</code></pre>"},{"location":"api_py/list/remove/","title":"remove","text":"<p><pre><code>async def remove(name:str, *, start: int = 0, stop: int = None) -&gt; None\n</code></pre> Remove items from a list using the range: <code>[start, stop)</code>.</p> <p><code>start</code> and <code>stop</code> use the same rules as get_range(), so negative and positive values are permitted, but they must translate to positions where <code>start &lt; stop</code>.</p>"},{"location":"api_py/list/remove/#examples","title":"Examples","text":"<pre><code>await list.create('rmv', type='int')\n\nawait list.add_head('rmv', [0,1,2,3,4,5,6,7,8,9,10])\nprint(await list.get_n('rmv'))\n\nawait list.remove('rmv', start=0, stop=3)\nprint(await list.get_n('rmv'))\n\nawait list.remove('rmv', start=1, stop=-1)\nprint(await list.get_n('rmv'))\n\nawait list.remove('rmv')  # remove all\nprint(await list.get_n('rmv'))\n</code></pre> Output<pre><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[3, 4, 5, 6, 7, 8, 9, 10]\n[3, 10]\n[]\n</code></pre>"},{"location":"api_py/list/remove_if_eq/","title":"remove_if_eq","text":"<p><pre><code>async def remove_if_eq(name:str, *, start: int = 0, stop: int = None, val):\n</code></pre> Search items in range: <code>[start, stop)</code>, removing those with value equal to <code>val</code>.</p> <p><code>start</code> and <code>stop</code> use the same rules as get_range(), so negative and positive values are permitted, but they must translate to positions where <code>start &lt; stop</code>.</p> <p>Note</p> <p>No gaurantees on behaviour if <code>val</code> is not the same type as when the list was created. This will be addressed in a future release.</p>"},{"location":"api_py/list/remove_if_eq/#examples","title":"Examples","text":"<pre><code>await list.create('rmv_if', type='int')\n\nawait list.add_head('rmv_if', [0,1,2,5,5,5,6,7,8,9,7,7,10])\nprint(await list.get_n('rmv_if'))\n\nawait list.remove_if_eq('rmv_if', start=0, stop=7, val=5)\nprint(await list.get_n('rmv_if'))\n\nawait list.remove_if_eq('rmv_if', start=-3, val=7)\nprint(await list.get_n('rmv_if'))\n</code></pre> Output<pre><code>[0, 1, 2, 5, 5, 5, 6, 7, 8, 9, 7, 7, 10]\n[0, 1, 2, 6, 7, 8, 9, 7, 7, 10]\n[0, 1, 2, 6, 7, 8, 9, 10]\n</code></pre>"}]}