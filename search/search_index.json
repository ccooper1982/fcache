{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>fcache is a FlatBuffers cache over WebSockets.</p> <p>There is support for key-values and lists, with more coming soon.</p> <p>FlatBuffers offer zero-copy deserialising: when the server receives data, it can deserialise without an intermediate step which requires allocating memory (as with ProtoBuf), and is considerably more compact than JSON.</p>"},{"location":"kv/","title":"Key Values","text":"<ul> <li>Key must be a string</li> <li>Supported values:    <ul> <li>integer</li> <li>unsigned integer</li> <li>float</li> <li>bool</li> <li>string</li> <li>List/vector/array of the above</li> </ul> </li> </ul>"},{"location":"kv/#listarrayvector-values","title":"List/Array/Vector Values","text":"<p>A value which is not scalar is serialised as a <code>TypedVector</code>. This means that all elements of the vector must be the same type. </p> <p>Using Python as an example:</p> Lists<pre><code>data =\n{\n  'animals':['cat', 'dog', 'horse'],\n  'scores':[50,55,5],\n  'anything':['xyz', 15, False]\n}\n</code></pre> <p>Storing <code>animals</code> and <code>scores</code> will succeed but <code>anything</code> will fail.</p>"},{"location":"kv/#groups","title":"Groups","text":"<p>Groups is a simple solution to separating related keys. Rather than using delimiters in keys such as <code>user1:name</code> and <code>user1:age</code>, you create a group for <code>user1</code> then store the <code>name</code> and <code>age</code> in that group.</p> <p>The group is a string that unique identifies an entity. For example for a user that could be an email address or user ID, or for hardware it could be a device ID or a MAC address.</p>"},{"location":"kv/#caching-json","title":"Caching JSON","text":"<p>There is no native JSON support, so JSON must be stored as either as a string or converting to a compatible dictionary/map structure.</p> <p>Note</p> <p>The Python API functions <code>set</code>, <code>add</code> and <code>clear_set</code> accept <code>dict</code> for key values.</p>"},{"location":"lists/","title":"Lists","text":"<p>A list is a node based doubly linked list with support for:</p> <ul> <li>integers (signed and unsigned)</li> <li>floats</li> <li>strings</li> </ul> <p>Lists can be sorted or unsorted: </p> <ul> <li>An unsorted list retains the order as added</li> <li>A sorted list ensures nodes are always in ascending order. If the items being added are already sorted, this can be signalled when adding, reducing workload </li> </ul> <p>For both sorted and unsorted lists get items:</p> <ul> <li>Based on a range <code>[start,stop)</code> with negative positions permitted (similar to Python slicing)</li> <li>Some commands have reverse versions which iterate the list from tail to head</li> </ul>"},{"location":"lists/#add-items","title":"Add Items","text":"<ul> <li>Unsorted List: items can be added anywhere in the list</li> <li>Sorted List: the list is sorted automatically, in ascending order</li> </ul>"},{"location":"lists/#get-items","title":"Get Items","text":"<p>The server API allows iterating a list from head to tail or tail to head.</p> <p>In the Python API there is <code>get_n()</code> which returns <code>n</code> items from a given starting position.</p> <pre><code>await lists.get_n('scores', start=0, count=3)\n</code></pre> <p>This returns the first three items.</p> <p>The reverse version iterates from the tail to head, so returns the last three items:</p> <pre><code>await lists.get_n_reverse('scores', start=0, count=3)\n</code></pre>"},{"location":"lists/#remove-items","title":"Remove Items","text":"<p>Items can be removed using their position or based on a value.</p> <p>For example, in the Python API we can remove nodes with a value of <code>100</code> in range <code>[0,8)</code>:</p> <pre><code>await lists.remove_if_eq('scores', start=0, stop=8, val=100)\n</code></pre>"},{"location":"lists/#intersect","title":"Intersect","text":"<p>Sorted lists of the same type can be intersected, with support for start/stop positions within each list.</p> <pre><code>await lst.create('i1', type='int')\nawait lst.create('i2', type='int')\n\nawait lst.add('i1', [0,1,2,5,5,5,6,7,8,9,10], items_sorted=True)\nawait lst.add('i2', [0,1,2,5,5,5,6,7], items_sorted=True)\n\nprint(await lst.intersect('i1', 'i2'))\nprint(await lst.intersect('i1', 'i2', l1_stop=6))\n\n# you can also set new_name_list, which creates a new list for\n# for the intersected items, rather than returning them\n</code></pre> Output<pre><code>[0, 1, 2, 5, 5, 5, 6, 7]\n[0, 1, 2, 5, 5, 5]\n</code></pre>"},{"location":"start/","title":"Build and Run","text":""},{"location":"start/#build","title":"Build","text":"<p>Note</p> <ul> <li>C++20 required</li> <li>Tested on GCC 13.2 and GCC 14.2</li> </ul> <ol> <li>From the repo root: <code>./build.sh</code> <ul> <li>Clones then builds the submodules</li> <li>Generates Flatbuffers code</li> </ul> </li> <li>Binary is in <code>server/release</code></li> </ol>"},{"location":"start/#run","title":"Run","text":""},{"location":"start/#command-line-arguments","title":"Command Line Arguments","text":"Name Description Default Notes ip The IP address the server will listen on 127.0.0.1 port The port 1987 maxPayload Max size, in bytes, of the WebSocket payload 16,384 Min: 64 bytesMax: 8 MB <p>Warning</p> <ul> <li>If a message exceeds <code>maxPayload</code> the client is disconnected</li> <li>Increase this value on the command line to avoid disconnections</li> <li>The absolute max is set in <code>fcache.cpp</code>. There is no particular reason for this value, other than it seems reasonable for most uses cases</li> </ul> <p>Custom IP: <pre><code>./fcache --ip=192.168.1.120\n</code></pre></p> <p>Default IP, custom port and max payload: <pre><code>./fcache --port=2000 --maxPayload=1048576\n</code></pre></p> <p>Note, no unit suffixes permitted (i.e. \"1MB\", etc).</p>"},{"location":"api_py/intro/","title":"Overview","text":"<p>The <code>fc.Client</code> manages the connection, with a separate class for KV specific commands (and in the future, arrays, lists, etc).</p> <p>The command classes require a <code>Client</code> object.</p>"},{"location":"api_py/intro/#connect","title":"Connect","text":"<pre><code>import fc\n\nasync def connect() -&gt; fc.Client:\n  try:\n    client = await fc.fcache(uri='ws://127.0.0.1:1987')\n    # or: client = await fc.fcache(ip='127.0.0.1', port=1987)\n  except:\n    print ('Failed to connect')\n    client = None\n  return client\n</code></pre>"},{"location":"api_py/intro/#exceptions","title":"Exceptions","text":"<ul> <li><code>ResponseError</code> : raised when a failed response is received</li> <li><code>ValueError</code> : raised by the API before a request is sent</li> <li><code>OSError</code> : if opening the connection fails</li> </ul>"},{"location":"api_py/intro/#kv","title":"KV","text":"<p>List Values</p> <ul> <li>A list cannot be empty</li> <li>If a key's value is a <code>list</code>, all elements must be the same type:</li> </ul> <pre><code>await kv.set({'a':[]})          # ValueError: empty, can't determine element type\nawait kv.set({'a':[1, 2, 3]})   # Ok\nawait kv.set({'b':[1, 2.5, 3]}) # ValueError: int, float, int    \n</code></pre> <pre><code>from fc.kv import KV\n\nasync def kv():\n  if (client := await connect()) is None:\n    return\n\n  # create API object for KV commands\n  kv = KV(client)\n\n  await kv.set({'player':'Monster',\n                'level':25,\n                'active':True,\n                'perks':['Armour','Kilt']})\n\n  # get single key, returns the value (or None if key not found)\n  age = await kv.get(key='level')\n  print(f'Age: {age}')\n\n  # get multiple keys, returns dict\n  rsp = await kv.get(keys=['player', 'active'])\n  print(f\"Player: {rsp['player']}, Active: {rsp['active']}\")\n\n  # get list\n  print(await kv.get(key='perks'))\n</code></pre> Output<pre><code>Age: 25\nPlayer: Monster, Active: True\n['Armour', 'Kilt']\n</code></pre>"},{"location":"api_py/intro/#types","title":"Types","text":"Python FlatBuffers/FlexBuffers Server int int <code>int64</code> float float <code>float</code> (4 bytes) str string <code>std::vector&lt;char&gt;</code> bool bool <code>bool</code> bytes BLOB <code>std::vector&lt;uint8_t&gt;</code> list[int] TypedVector: VECTOR_INT <code>std::vector&lt;int64&gt;</code> list[float] TypedVector: VECTOR_FLOAT <code>std::vector&lt;float&gt;</code> list[str] TypedVector: VECTOR_KEY <code>std::vector&lt;uint8_t&gt;</code> list[bool] TypedVector: VECTOR_BOOL <code>std::vector&lt;bool&gt;</code> <p>Note</p> <p>A <code>TypedVector</code> is a type of FlexBuffer vector, where each element is the same type.</p>"},{"location":"api_py/intro/#lists","title":"Lists","text":"<p>Lists are node based doubly linked lists. There are two types, <code>SortedList</code> and <code>UnsortedList</code>.</p>"},{"location":"api_py/intro/#unsorted","title":"Unsorted","text":"Unsorted<pre><code>from fc.list import UnsortedList\n\nasync def unsorted_lists():\n  if (client := await connect()) is None:\n    return\n\n  # create API object for list functions\n  list = List(client)\n\n  # delete any existing lists\n  await list.delete_all()\n\n  # create list for integers\n  await list.create('scores', type='int')\n  # add these items to head\n  await list.add_head('scores', [25,35,45,55])\n  # insert in between 35 and 45 (at position 2)\n  await list.add('scores', [40], pos=2)\n  # add two more to the tail\n  await list.add_tail('scores', [60, 65])\n\n  # get everything from the first item\n  print(f\"a. {await list.get_n('scores')}\")\n  # get everything in reverse\n  print(f\"b. {await list.get_n_reverse('scores')}\")\n  # # get the first 3 \n  print(f\"c. {await list.get_n('scores', count=3)}\")\n  # # get the last 2\n  print(f\"d. {await list.get_n('scores', start=5)}\")\n  # get middle 3 with range (could also use get_n())\n  print(f\"e. {await list.get_range('scores', start=2, stop=5)}\")\n  # get middle 5 in reverse, using negative index\n  print(f\"f. {await list.get_range_reverse('scores', start=1, stop=-1)}\")\n</code></pre> Output<pre><code>a. [25, 35, 40, 45, 55, 60, 65]\nb. [65, 60, 55, 45, 40, 35, 25]\nc. [25, 35, 40]\nd. [60, 65]\ne. [40, 45, 55]\nf. [60, 55, 45, 40, 35]\n</code></pre>"},{"location":"api_py/intro/#sorted","title":"Sorted","text":"Sorted<pre><code>from fc.list import SortedList\n\nasync def sorted_lists():\n  if (client := await connect()) is None:\n    return\n\nlst = SortedList(client)\n\nawait lst.delete_all()\n\nawait lst.create('scores', type='int')\n\nawait lst.add('scores', [45,35,25,55])\nprint(await lst.get_n('scores'))\n\nawait lst.add('scores', [50,20,100,40,90])\nprint(await lst.get_n('scores'))\n\nawait lst.add('scores', [41,42], items_sorted=True)\nprint(await lst.get_n('scores'))\n\nawait lst.add('scores', [1,2,3], items_sorted=True)\nprint(await lst.get_n('scores'))\n\nawait lst.add('scores', [100,101,102], items_sorted=True)\nprint(await lst.get_n('scores'))\n\nprint(await lst.get_n('scores', start=5, count=4))\nprint(await lst.get_n_reverse('scores', start=8, count=4))\n</code></pre> Output<pre><code>[25, 35, 45, 55]\n[20, 25, 35, 40, 45, 50, 55, 90, 100]\n[20, 25, 35, 40, 41, 42, 45, 50, 55, 90, 100]\n[1, 2, 3, 20, 25, 35, 40, 41, 42, 45, 50, 55, 90, 100]\n[1, 2, 3, 20, 25, 35, 40, 41, 42, 45, 50, 55, 90, 100, 100, 101, 102]\n[35, 40, 41, 42]\n[42, 41, 40, 35]\n</code></pre>"},{"location":"api_py/kv/add/","title":"add","text":"<pre><code>async def add(kv: dict, group: str = None) -&gt; None\n</code></pre> <p>The same as set except if a key already exists, the value is not replaced.</p>"},{"location":"api_py/kv/add/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True})\n# calling add() will not update age\nawait kv.add({'age':35})\n</code></pre>"},{"location":"api_py/kv/clear/","title":"clear","text":"<pre><code>async def clear() -&gt; None\n</code></pre> <p>Deletes all keys and all groups.</p> <p>You can also use <code>clear_set()</code> to delete all keys then set new keys in a single call.</p>"},{"location":"api_py/kv/clear/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True, 'city':'London'})\nawait kv.clear()\n</code></pre>"},{"location":"api_py/kv/clear_group/","title":"clear_group","text":"<pre><code>async def clear_group(name:str, delete_group:bool = True) -&gt; None:\n</code></pre> <p>Deletes all keys in a group, and optionally will also delete the group.</p>"},{"location":"api_py/kv/clear_group/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25}, group='g1')\n\nawait kv.clear_group('g1', False) # group still exists, but has no keys\n\nawait kv.clear_group('g1') # now group is deleted\n</code></pre>"},{"location":"api_py/kv/clear_groups/","title":"clear_groups","text":"<pre><code>async def clear_groups(delete_groups:bool = True) -&gt; None:\n</code></pre> <p>Delete all groups or only delete keys in all groups.</p> <p>If <code>delete_groups</code> is <code>True</code>, all groups deleted. Otherwise, all groups have keys deleted, but the groups still exist.</p>"},{"location":"api_py/kv/clear_groups/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25}, group='g1')\nawait kv.set({'user':'user2', 'age':45}, group='g2')\n\nawait kv.clear_groups(False) # g1 and g2 still exist, but have no keys\nawait kv.clear_groups() # all groups deleted\n</code></pre>"},{"location":"api_py/kv/clear_set/","title":"clear_set","text":"<pre><code>async def clear_set(kv:dict, group:str = None) -&gt; None:\n</code></pre> <p>Deletes all keys then sets new keys in a single command.</p> <p>This command may be more convenient or efficient than using set.</p> <p>This is useful if there are many keys to update and the full set of keys are available. This is convenient to add new keys, update existing keys and delete keys that are no longer required.</p>"},{"location":"api_py/kv/clear_set/#examples","title":"Examples","text":"<pre><code>await kv.set({'k1':10, 'k2':20})\nawait kv.clear_set({'k3':30, 'k4':40})\n# only k3 and k4 exist\n</code></pre> With Group<pre><code>await kv.set({   \n                'username':'some_username',\n                'city':'London',\n                'status':'Active',\n                'client_version':2\n              },\n              group='a@xyz.com')\n\n# update existing keys (username, status), set a new key (age) and\n# delete unused key (client_version)\nawait kv.clear_set({\n                      'username':'new_username',\n                      'city':'London',\n                      'age':55,\n                      'status':'AuthRequired'\n                   },\n                   group='a@xyz.com')\n</code></pre>"},{"location":"api_py/kv/contains/","title":"contains","text":"<pre><code>async def contains(keys: list, *, group: str = None) -&gt; set\n</code></pre> <p>Given a list of keys, return those which exist.</p>"},{"location":"api_py/kv/contains/#returns","title":"Returns","text":"<p>A <code>set</code> of keys that exist. If no keys exist, an empty set is returned.</p>"},{"location":"api_py/kv/contains/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True, 'city':'London'})\nawait kv.contains(['age','user','dont_exist']) # returns {'age','user'}\n</code></pre>"},{"location":"api_py/kv/count/","title":"count","text":"<pre><code>async def count(*, group: str = None) -&gt; int\n</code></pre> <p>Gets the number of keys.</p> <p>If <code>group</code> is set, the count only applies to that group.</p>"},{"location":"api_py/kv/count/#returns","title":"Returns","text":"<p>The number of keys that exist. If <code>group</code> is set but does not exist, <code>0</code> is returned.</p>"},{"location":"api_py/kv/count/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True, 'city':'London'})\ncount = await kv.count() # 4\n</code></pre>"},{"location":"api_py/kv/get/","title":"get","text":"<pre><code>async def get(*,  key:str = None,\n                  keys:List[str] = [],\n                  group:str = None) -&gt; dict | Any\n</code></pre> <p>Gets a single key or multiple keys.</p>"},{"location":"api_py/kv/get/#returns","title":"Returns","text":"<p>Called with:</p> <ul> <li><code>key</code>: if key exists the value is returned, otherwise <code>None</code></li> <li><code>keys</code>: all key values in a <code>dict</code>. If no keys exist, an empty <code>dict</code> is returned</li> </ul>"},{"location":"api_py/kv/get/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True})\n\n# get single key, returns the value\nage = await kv.get(key='age')\nprint(f'Age: {age}')\n\n# get multiple keys, returns dict\nrsp = await kv.get(keys=['user', 'active'])\nprint(f\"User: {rsp['user']}, Active: {rsp['active']}\")\n</code></pre> <pre><code>Age: 25\nUser: user1, Active: True\n</code></pre>"},{"location":"api_py/kv/remove/","title":"remove","text":"<pre><code>async def remove(*, key:str = None,\n                    keys:List[str] = list(),\n                    group: str = None) -&gt; None:\n</code></pre> <p>Deletes one or multiple keys.</p> <ul> <li><code>key</code> : individual key to delete</li> <li><code>keys</code> : list of keys to delete</li> </ul> <p>If a key does not exist it is not considered an error.</p>"},{"location":"api_py/kv/remove/#examples","title":"Examples","text":"<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True, 'city':'London'})\nawait kv.remove(key='age')\nawait kv.remove(keys=['user','city'])\n# only 'active' remains\n</code></pre>"},{"location":"api_py/kv/set/","title":"set","text":"<pre><code>async def set(kv:dict, group:str = None) -&gt; None\n</code></pre> <p>Sets new key(s). If a key already exists, the value is replaced.</p> <ul> <li><code>kv</code> : the key-values, where a value can be: int, str, float, bool or a list of those.</li> <li><code>group</code> : a group name into which the keys will be stored</li> </ul> <p>The <code>group</code> is created if it does not exist.</p> <p>Note</p> <p>If a value is a list, all elements in the list must be the same type.</p>"},{"location":"api_py/kv/set/#examples","title":"Examples","text":"Basics<pre><code>await kv.set({'user':'user1', 'age':25, 'active':True})\n</code></pre> Blob<pre><code>file_data = bytes()\nwith open('cat.jpg', mode='rb') as file:\n  file_data = file.read()\n\nkv = KV(client)\n\nawait kv.set({'img_cat':file_data})\n\nif data := await kv.get(key='img_cat'):\n  with open('cat_rsp.jpg', mode='wb') as file:\n    file.write(data)\n    print('Image written')\n</code></pre> Groups<pre><code>await kv.set({'username':'user1', 'city':'London'}, group='a@xyz.com')\nawait kv.set({'username':'user2', 'city':'Paris'}, group='b@xyz.com')\n\nprint(await kv.get(key='username', group='a@xyz.com'))\nprint(await kv.get(key='username', group='b@xyz.com'))\n\nprint(await kv.get(keys=['username', 'city'], group='a@xyz.com'))\nprint(await kv.get(keys=['username', 'city'], group='b@xyz.com'))\n</code></pre> Output<pre><code>user1\nuser2\n{'city': 'London', 'username': 'user1'}\n{'city': 'Paris', 'username': 'user2'}\n</code></pre>"},{"location":"api_py/list/add/","title":"add","text":"<p>Unsorted List <pre><code>async def add(name: str,\n              items: List[int|str|float], *,\n              pos:int = 0) -&gt; int\n</code></pre></p> <p>Sorted List <pre><code>async def add(name: str,\n              items: List[int|str|float],\n              items_sorted:bool = False) -&gt; int\n</code></pre></p> <p>Both functions insert items but <code>pos</code> cannot be defined for a sorted list.</p> <p>All elements in <code>items</code> must be the same type as when <code>list</code> was created.</p>"},{"location":"api_py/list/add/#unsorted","title":"Unsorted","text":"Param Info pos The position to begin inserting <p>Inserts items into the list, starting at position <code>pos</code>, in the same order as <code>items</code>.</p> <ul> <li>If <code>abs(pos)</code> is greater than the list size, the items are appended</li> </ul>"},{"location":"api_py/list/add/#sorted","title":"Sorted","text":"Param Info items_sorted <code>True</code>: set only if <code>items</code> are already sorted in ascending order<code>False</code>: the server handles sorting"},{"location":"api_py/list/add/#returns","title":"Returns","text":"<p>Both functions return the length of the list after adding <code>items</code>.</p>"},{"location":"api_py/list/add/#examples","title":"Examples","text":"Unsorted<pre><code># lst is a fc.list.UnsortedList\n\nawait lst.create('names', type='str')\n\nawait lst.add('names', ['Arya', 'Fiona']) # same as add_head()\nprint(await lst.get_n('names'))\n\nawait lst.add('names', ['David', 'Bob', 'Charlie'], pos=1)\nprint(await lst.get_n('names'))\n\nfinalSize = await lst.add('names', ['Emma'], pos=3)\nprint(f'Final size: {finalSize}')\nprint(await lst.get_n('names'))\n</code></pre> Output<pre><code>['Arya', 'Fiona']\n['Arya', 'David', 'Bob', 'Charlie', 'Fiona']\n['Arya', 'David', 'Bob', 'Emma', 'Charlie', 'Fiona']\nFinal size: 6\n</code></pre> Sorted<pre><code># lst is a fc.list.SortedList\n\nawait lst.create('names', type='str')\n\nawait lst.add('names', ['Arya', 'Fiona'], items_sorted=True)\nprint(await lst.get_n('names'))\n\nawait lst.add('names', ['David', 'Bob', 'Charlie'])\nprint(await lst.get_n('names'))\n\nawait lst.add('names', ['Emma'])\nprint(await lst.get_n('names'))\n</code></pre> Output<pre><code>['Arya', 'Fiona']\n['Arya', 'Bob', 'Charlie', 'David', 'Fiona']\n['Arya', 'Bob', 'Charlie', 'David', 'Emma', 'Fiona']\n</code></pre>"},{"location":"api_py/list/add_head/","title":"add_head","text":"<p><pre><code>async def add_head(name: str, items: typing.List[int|str|float]) -&gt; int\n</code></pre> Adds to items to the list's head. Items are added in the same order as <code>items</code>.</p> Param Info name Name of the list items The items to add to the list. Each item must be of the appropriate type for the list."},{"location":"api_py/list/add_head/#returns","title":"Returns","text":"<p>The length of the list after adding <code>items</code>.</p>"},{"location":"api_py/list/add_head/#examples","title":"Examples","text":"<pre><code>await list.create('names', type='str')\nawait list.add_head('names', ['Arya', 'Charlie'])\n# [Arya, Charlie]\nawait list.add_head('names', ['Adam', 'Alice'])\n# [Adam, Alice, Arya, Charlie]\n</code></pre>"},{"location":"api_py/list/add_tail/","title":"add_tail","text":"<p><pre><code>async def add_tail(name: str, items: typing.List[int|str|float]) -&gt; int\n</code></pre> Appends items to the list. Items are added in the same order as <code>items</code>.</p> Param Info name Name of the list items The items to add to the list. Each item must be of the appropriate type for the list."},{"location":"api_py/list/add_tail/#returns","title":"Returns","text":"<p>The length of the list after adding <code>items</code>.</p>"},{"location":"api_py/list/add_tail/#examples","title":"Examples","text":"<pre><code>await list.create('names', type='str')\n# you can add_tail() on an empty list\nawait list.add_tail('names', ['Arya', 'Charlie'])\n# [Arya, Charlie] , Arya is the head, Charlie the tail\nawait list.add_tail('names', ['David', 'Fiona'])\n# [Arya, Charlie, David, Fiona]\n</code></pre>"},{"location":"api_py/list/create/","title":"create","text":"<pre><code>async def create(name: str, *, type: str, fail_on_duplicate:bool = True) -&gt; None\n</code></pre> <p>Creates a new list with the given name and type.</p> Param Info name Name of the list, used in subsequent list functions type Must be one of: <code>int</code>, <code>float</code> or <code>str</code> fail_on_duplicate <code>True</code>: <code>ResponseError</code> is raised if a list with this <code>name</code> already exists<code>False</code>: if the name already exists, no changes are made to the existing list and an <code>ResponseError</code> is not raised"},{"location":"api_py/list/create/#examples","title":"Examples","text":"<pre><code># create an int list called 'scores' and add four items\nawait list.create('scores', type='int')\nawait list.add_head('scores', [1,2,3,4])\n\n# string list\nawait list.create('names', type='str')\nawait list.add_head('names', ['Alice', 'Charlie'])\nawait list.add('names', ['Bob'], pos=1)\nawait list.add_tail('names', ['David'])\n# [Alice, Bob, Charlie, David]\n</code></pre>"},{"location":"api_py/list/delete/","title":"delete","text":"<p><pre><code>async def delete(names: typing.List[str]) -&gt; None\n</code></pre> Delete list(s).</p> <p>To delete all lists without specifying each name, use delete_all().</p>"},{"location":"api_py/list/delete/#examples","title":"Examples","text":"<pre><code>await list.create('scores', type='int')\nawait list.create('usernames', type='str')\nawait list.create('foo', type='int')\n\nawait list.delete(['scores', 'usernames'])\n# now only 'foo' list exists\n</code></pre>"},{"location":"api_py/list/delete_all/","title":"delete_all","text":"<p><pre><code>async def delete_all() -&gt; None\n</code></pre> Delete all lists.</p> <p>To delete particular list(s) by name, use delete().</p>"},{"location":"api_py/list/delete_all/#examples","title":"Examples","text":"<pre><code>await list.create('scores', type='int')\nawait list.create('usernames', type='str')\nawait list.create('foo', type='int')\nawait list.delete_all()\n</code></pre>"},{"location":"api_py/list/get_head/","title":"get_head","text":"<pre><code>async def get_head(name: str):\n</code></pre> <p>Returns the item at the head.</p>"},{"location":"api_py/list/get_head/#returns","title":"Returns","text":"<p>If the list is empty returns <code>None</code>, otherwise the item.</p>"},{"location":"api_py/list/get_head/#examples","title":"Examples","text":"<pre><code>await list.create('names', type='str')\nawait list.add_head('names', ['Arya', 'Fiona'])\nprint(await list.get_head('names')) # 'Arya'\n</code></pre>"},{"location":"api_py/list/get_n/","title":"get_n","text":"<pre><code>async def get_n(name: str, *, start: int = 0, count: int = None) -&gt; list:\n</code></pre> <p>Returns <code>count</code> number of items, beginning from <code>start</code> position.</p> <ul> <li> <p><code>count</code></p> <ul> <li><code>None</code> will get until to and including the tail</li> <li>Cannot be negative</li> </ul> </li> <li> <p><code>start</code> cannot be negative</p> </li> </ul> <p>Note</p> <p><code>start</code> is zero based. The head is <code>0</code>.</p>"},{"location":"api_py/list/get_n/#examples","title":"Examples","text":"<pre><code>await list.create('list', type='str')\nawait list.add_head('list', ['A', 'B', 'C', 'D', 'E'])\n\nprint(await list.get_n('list'))           # all from head\nprint(await list.get_n('list', start=3))  # all from 4th item\nprint(await list.get_n('list', start=1, count=2)) # 2 from 2nd item\nprint(await list.get_n('list', count=3))          # 3 from head\n</code></pre> Output<pre><code>['A', 'B', 'C', 'D', 'E']\n['D', 'E']\n['B', 'C']\n['A', 'B', 'C']\n</code></pre>"},{"location":"api_py/list/get_n_reverse/","title":"get_n_reverse","text":"<pre><code>async def get_n_reverse(name: str, *, start: int = 0, count: int = None) -&gt; list:\n</code></pre> <p>Returns <code>count</code> number of items, beginning from <code>start</code> position, iterating from tail to head.</p> <p>This is the same as get_n() but<code>start</code> is relative to the tail: i.e. <code>start = 0</code> is the tail.</p> <ul> <li> <p><code>count</code></p> <ul> <li><code>None</code> will get to and including the head</li> <li>Cannot be negative</li> </ul> </li> <li> <p><code>start</code> cannot be negative</p> </li> </ul>"},{"location":"api_py/list/get_n_reverse/#examples","title":"Examples","text":"<pre><code>await lst.create('chars', type='str')\nawait lst.add('chars', ['A', 'B', 'C', 'D', 'E'])\n\nprint(await lst.get_n_reverse('chars'))           \nprint(await lst.get_n_reverse('chars', start=3))  \nprint(await lst.get_n_reverse('chars', start=1, count=2)) \nprint(await lst.get_n_reverse('chars', count=3))          \n</code></pre> Output<pre><code>['E', 'D', 'C', 'B', 'A']\n['B', 'A']\n['D', 'C']\n['E', 'D', 'C']\n</code></pre>"},{"location":"api_py/list/get_range/","title":"get_range","text":"<pre><code>async def get_range(name: str, *, start:int, stop: int = None) -&gt; list:\n</code></pre> <p>Get items using the range: <code>[start, stop)</code>.</p> <p>If <code>stop</code> is <code>None</code>, returns all remaining.</p> <p><code>start</code> and <code>stop</code> can be negative, similar to Python slicing:</p> <ul> <li><code>-1</code> is the tail</li> <li><code>-2</code> is the node before the tail</li> </ul> <p>Either or both <code>start</code> and <code>stop</code> can be negative/positive, but they must represent indices such that <code>start &lt; stop</code>.</p>"},{"location":"api_py/list/get_range/#returns","title":"Returns","text":"<p>A list of node values. The list will be empty if:</p> <ul> <li>the range is invalid</li> <li><code>start == stop</code></li> </ul>"},{"location":"api_py/list/get_range/#examples","title":"Examples","text":"<pre><code>await list.create('list', type='str')\nawait list.add_head('list', ['A', 'B', 'C', 'D', 'E'])\n\nprint(await list.get_range('list', start=0))\nprint(await list.get_range('list', start=2))\nprint(await list.get_range('list', start=-2))\nprint(await list.get_range('list', start=1, stop=-2))\nprint(await list.get_range('list', start=-4, stop=-1))\n\n# invalid: [3,1)\nprint(await list.get_range('list', start=-2, stop=1))\n# invalid: [3,2)\nprint(await list.get_range('list', start=3, stop=-3))\n</code></pre> Output<pre><code>['A', 'B', 'C', 'D', 'E']\n['C', 'D', 'E']\n['D', 'E']\n['B', 'C']\n['B', 'C', 'D']\n[]\n[]\n</code></pre>"},{"location":"api_py/list/get_range/#notes","title":"Notes","text":"<p>The API performs simple checks on the ranges to spot problems before sending the query, but it's not always possible without knowing the list's size.</p> <p>Consider the example above, this range is invalid:</p> <pre><code>print(await list.get_range('list', start=3, stop=-3))\n</code></pre> <p>But add two items and try again:</p> <pre><code>await list.add_tail('list', ['F','G'])\n# now [3,4)\nprint(await list.get_range('list', start=3, stop=-3)) \n</code></pre> Output<pre><code>['D']\n</code></pre>"},{"location":"api_py/list/get_range_reverse/","title":"get_range_reverse","text":"<p><pre><code>async def get_range_reverse(name: str, *, start:int, stop: int = None) -&gt; list:\n</code></pre> Get items in range <code>[start, stop)</code>, but iterates from tail to head.</p> <p>This is the same as get_range() but positions are relative to the tail, i.e.:</p> <ul> <li><code>start = 0</code> is the tail node</li> <li><code>start = -1</code> is the head node</li> </ul> <p>If <code>stop</code> is <code>None</code>, returns all remaining.</p> <p>Either or both <code>start</code> and <code>stop</code> can be negative/positive, but they must represent indices such that <code>start &lt; stop</code>.</p>"},{"location":"api_py/list/get_range_reverse/#returns","title":"Returns","text":"<p>A list of node values. The list will be empty if:</p> <ul> <li>the range is invalid</li> <li><code>start == stop</code></li> </ul>"},{"location":"api_py/list/get_range_reverse/#examples","title":"Examples","text":"<pre><code>await list.create('list', type='str')\nawait list.add_head('list', ['A', 'B', 'C', 'D', 'E'])\n\nprint(await list.get_range_reverse('list', start=0))    # 0 is the tail\nprint(await list.get_range_reverse('list', start=2))\nprint(await list.get_range_reverse('list', start=-2))\nprint(await list.get_range_reverse('list', start=1, stop=-2))\nprint(await list.get_range_reverse('list', start=-4, stop=-1))\n</code></pre> Output<pre><code>['E', 'D', 'C', 'B', 'A']\n['C', 'B', 'A']\n['B', 'A']\n['D', 'C']\n['D', 'C', 'B']\n</code></pre>"},{"location":"api_py/list/get_tail/","title":"get_tail","text":"<pre><code>async def get_tail(name: str):\n</code></pre> <p>Returns the item at the tail.</p>"},{"location":"api_py/list/get_tail/#returns","title":"Returns","text":"<p>If the list is empty returns <code>None</code>, otherwise the item.</p>"},{"location":"api_py/list/get_tail/#examples","title":"Examples","text":"<pre><code>await list.create('names', type='str')\nawait list.add_head('names', ['Arya', 'Fiona'])\nprint(await list.get_tail('names')) # 'Fiona'\n</code></pre>"},{"location":"api_py/list/intersect/","title":"intersect","text":"<pre><code>async def intersect(list1: str, list2: str, *,\n                    l1_start:int=0, l1_stop:int=None,\n                    l2_start:int=0, l2_stop:int=None,\n                    new_list_name:str=None) -&gt; None | typing.List[int|float|str]\n</code></pre> <p>Intersects <code>list1</code> and <code>list2</code>. They must the same type.</p> <p>Positions within each list can be defined, with defaults applying the intersection over both entire lists.</p> Param Info list1, list2 The lists to intersect l1_start, l1_stop Restricts the nodes for intersecting within <code>list1</code>. Note, <code>l1_stop</code> is exclusive. Set <code>l1_stop=None</code> to including all remaining nodes l2_start, l2_stop Restricts the nodes for intersecting within <code>list2</code>. Note, <code>l2_stop</code> is exclusive.Set <code>l2_stop=None</code> to including all remaining nodes new_list_name - If <code>None</code>: intersected nodes are returned- Otherwise creates a new list for the intersected nodes, and does not return the nodes  <ul> <li><code>l1_start</code> and <code>l1_stop</code> restrict the intersection in <code>list1</code> to <code>[l1_start, l1_stop)</code></li> <li><code>l2_start</code> and <code>l2_stop</code> restrict the intersection in <code>list2</code> to <code>[l2_start, l2_stop)</code></li> </ul> <p>Stop position of <code>None</code> includes all remaining nodes in the list.</p>"},{"location":"api_py/list/intersect/#returns","title":"Returns","text":"<p>It depends on <code>new_list_name</code>:</p> <ul> <li>If <code>None</code>:<ul> <li>Returns the intersected nodes</li> </ul> </li> <li>If a valid string:<ul> <li>Returns <code>None</code></li> <li>The intersected nodes are added to the new list</li> </ul> </li> </ul>"},{"location":"api_py/list/intersect/#examples","title":"Examples","text":"<p>The code comments below exclude the value at the stop position as it's exclusive.</p> Int Lists<pre><code>await lst.create('i1', type='int')\nawait lst.create('i2', type='int')\n\nawait lst.add('i1', [0,1,2,5,5,5,6,7,8,9,10], items_sorted=True)\nawait lst.add('i2', [0,1,2,5,5,5,6,7], items_sorted=True)\n\n# entire lists\nprint(await lst.intersect('i1', 'i2'))\n\n# [0,1,2,5,5,5] n [0,1,2,5,5,5,6,7]\nprint(await lst.intersect('i1', 'i2', l1_stop=6))\n\n# [0,1,2,5,5,5,6,7,8,9,10] n [0,1,2]\nprint(await lst.intersect('i1', 'i2', l2_stop=3))\n\n# [5,5,5] n [0,1,2,5,5,5]\nprint(await lst.intersect('i1', 'i2', l1_start=3, l1_stop=6, l2_stop=-2))\n</code></pre> Output<pre><code>[0, 1, 2, 5, 5, 5, 6, 7]\n[0, 1, 2, 5, 5, 5]\n[0, 1, 2]\n[5, 5, 5]\n</code></pre> <p></p> String Lists<pre><code>await lst.create('s1', type='str')\nawait lst.create('s2', type='str')\n\nawait lst.add('s1', ['apple', 'cider', 'painful', 'tequila', 'yes'], items_sorted=True)\nawait lst.add('s2', ['apple', 'beer', 'cider', 'no', 'painful', 'tequila'], items_sorted=True)\n\n# entire lists\nprint(await lst.intersect('s1', 's2'))\n\n# ['apple', 'cider'] n ['apple', 'beer', 'cider']\nprint(await lst.intersect('s1', 's2', l1_stop=2, l2_stop=-3))\n\n# ['painful', 'tequila', 'yes'] n ['painful', 'tequila']\nprint(await lst.intersect('s1', 's2', l1_start=2, l2_start=4))\n</code></pre> Output<pre><code>['apple', 'cider', 'painful', 'tequila']\n['apple', 'cider']\n['painful', 'tequila']\n</code></pre> <p></p> Create new list from intersected nodes<pre><code>await lst.create('list1', type='int')\nawait lst.create('list2', type='int')\n\nawait lst.add('list1', [1,2,3,4,5,6,7,8,9,10], items_sorted=True)\nawait lst.add('list2', [1,2,9,10], items_sorted=True)\n\nawait lst.intersect('list1', 'list2', new_list_name='list3')\nprint(await lst.get_n('list3'))\n</code></pre> Output<pre><code>[1, 2, 9, 10]\n</code></pre>"},{"location":"api_py/list/remove/","title":"remove","text":"<p><pre><code>async def remove(name:str, *, start: int = 0, stop: int = None) -&gt; None\n</code></pre> Remove items from a list using the range: <code>[start, stop)</code>.</p> <p><code>start</code> and <code>stop</code> use the same rules as get_range(), so negative and positive values are permitted, but they must translate to positions where <code>start &lt; stop</code>.</p>"},{"location":"api_py/list/remove/#examples","title":"Examples","text":"<pre><code>await list.create('rmv', type='int')\n\nawait list.add_head('rmv', [0,1,2,3,4,5,6,7,8,9,10])\nprint(await list.get_n('rmv'))\n\nawait list.remove('rmv', start=0, stop=3)\nprint(await list.get_n('rmv'))\n\nawait list.remove('rmv', start=1, stop=-1)\nprint(await list.get_n('rmv'))\n\nawait list.remove('rmv')  # remove all\nprint(await list.get_n('rmv'))\n</code></pre> Output<pre><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[3, 4, 5, 6, 7, 8, 9, 10]\n[3, 10]\n[]\n</code></pre>"},{"location":"api_py/list/remove_head/","title":"remove_head","text":"<pre><code>async def remove_head(name:str) -&gt; None\n</code></pre> <p>Removes the head node.</p>"},{"location":"api_py/list/remove_if_eq/","title":"remove_if_eq","text":"<p><pre><code>async def remove_if_eq( name:str, *,\n                        start: int = 0,\n                        stop: int = None,\n                        val: str|int|float) -&gt; int\n</code></pre> Search items in range: <code>[start, stop)</code>, removing those with value equal to <code>val</code>.</p> <p><code>start</code> and <code>stop</code> use the same rules as get_range(), so negative and positive values are permitted, but they must translate to indices where <code>start &lt; stop</code>.</p> <p>Note</p> <p>No gaurantees on behaviour if <code>val</code> is not the same type as when the list was created. This will be addressed in a future release.</p>"},{"location":"api_py/list/remove_if_eq/#returns","title":"Returns","text":"<p>Length of the list after nodes removed.</p>"},{"location":"api_py/list/remove_if_eq/#examples","title":"Examples","text":"<pre><code>await list.create('rmv_if', type='int')\n\nawait list.add('rmv_if', [0,1,2,5,5,5,6,7,8,9,7,7,10])\nprint(await list.get_n('rmv_if'))\n\nawait list.remove_if_eq('rmv_if', start=0, stop=7, val=5)\nprint(await list.get_n('rmv_if'))\n\nawait list.remove_if_eq('rmv_if', start=-3, val=7)\nprint(await list.get_n('rmv_if'))\n</code></pre> Output<pre><code>[0, 1, 2, 5, 5, 5, 6, 7, 8, 9, 7, 7, 10]\n[0, 1, 2, 6, 7, 8, 9, 7, 7, 10]\n[0, 1, 2, 6, 7, 8, 9, 10]\n</code></pre>"},{"location":"api_py/list/remove_tail/","title":"remove_tail","text":"<pre><code>async def remove_tail(name:str) -&gt; None\n</code></pre> <p>Removes the tail node.</p>"},{"location":"api_py/list/set/","title":"set","text":"<pre><code>async def set(name:str, items: typing.List[int|str|float], *, pos:int=0):\n</code></pre> <p>Replace list node values, starting at <code>pos</code>, with <code>items</code>. The list items are overwritten in the same order as <code>items</code>.</p> <ul> <li>All <code>items</code> must be the same type </li> <li>The type must be the same as when the list was created</li> </ul> <p>Items are overwritten until either the end of items or end of list.</p>"},{"location":"api_py/list/set/#examples","title":"Examples","text":"<pre><code>await list.create('chars', type='str')\nawait list.add_head('chars', ['A','B','X','Y','Z','F','G'])\nprint(await list.get_n('chars'))\n\n# replace 'X'\nawait list.set('chars', ['C'], pos=2)\nprint(await list.get_n('chars'))\n\n# replace 'Y','Z'\nawait list.set('chars', ['D','E'], pos=3)\nprint(await list.get_n('chars'))\n\n# replace last four\nawait list.set('chars', ['H','E', 'L','O'], pos=-4)\nprint(await list.get_n('chars'))\n</code></pre> Output<pre><code>['A', 'B', 'X', 'Y', 'Z', 'F', 'G']\n['A', 'B', 'C', 'Y', 'Z', 'F', 'G']\n['A', 'B', 'C', 'D', 'E', 'F', 'G']\n['A', 'B', 'C', 'H', 'E', 'L', 'O']\n</code></pre>"}]}